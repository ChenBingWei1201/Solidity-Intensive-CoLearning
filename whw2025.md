---
timezone: Asia/Shanghai
---

> 请在上边的 timezone 添加你的当地时区，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区
> 时区请参考以下列表，请移除 # 以后的内容

timezone: Pacific/Honolulu # 夏威夷-阿留申标准时间 (UTC-10)

timezone: America/Anchorage # 阿拉斯加夏令时间 (UTC-8)

timezone: America/Los_Angeles # 太平洋夏令时间 (UTC-7)

timezone: America/Denver # 山地夏令时间 (UTC-6)

timezone: America/Chicago # 中部夏令时间 (UTC-5)

timezone: America/New_York # 东部夏令时间 (UTC-4)

timezone: America/Halifax # 大西洋夏令时间 (UTC-3)

timezone: America/St_Johns # 纽芬兰夏令时间 (UTC-2:30)

timezone: Asia/Dubai # 海湾标准时间 (UTC+4)

timezone: Asia/Kolkata # 印度标准时间 (UTC+5:30)

timezone: Asia/Dhaka # 孟加拉国标准时间 (UTC+6)

timezone: Asia/Bangkok # 中南半岛时间 (UTC+7)

timezone: Asia/Shanghai # 中国标准时间 (UTC+8)

timezone: Asia/Tokyo # 日本标准时间 (UTC+9)

timezone: Australia/Sydney # 澳大利亚东部标准时间 (UTC+10)

---

# {whw2025}

1. 我是一个web3新人，之前没有接触过任何编程，但对此非常感兴趣，很有幸碰到这样的学习机会；希望可以通过学习提升自己。

2. 确实由于完全没有相关基础，估计会有困难，但会尽力完成。
   
## Notes

<!-- Content_START -->

### 2024.09.23

第一节：hello web3

1、// SPDX-License-Identifier: MIT
说明代码的软件许可；不写许可，编译时会出现警告（warning）；Solidity 注释以“//”开头；即表示新开启一个小项；

2、pragma solidity ^0.8.21;
该行表示Solidity使用的版本；Solidity 语句以分号（;）结尾

3、contract HelloWeb3 {
    string public _string = "Hello Web3!";
}
contract后面表示为合约名；{}中表示为合约内容；_string定义的内容为Hello Web3!

问题1：}是否必须另起一行？


第二节：值类型

4、变量类型包括：值类型(Value Type)、引用类型(Reference Type)、映射类型(Mapping Type)；

5、值类型包括：布尔型、整型、地址类型、定长字节数组、枚举 enum

1）布尔型是二值变量，取值为 true 或 false

布尔值的运算符包括：
! （逻辑非）
&& （逻辑与，"and"）
|| （逻辑或，"or"）
== （等于）
!= （不等于）

问题2：
_bool && _bool1 为 false；_bool || _bool1 为 true；那么结合前面的陈述，这里的_bool 是以“true”取值吗？是否表示“true && false”为false；“true || false”为true；

&& 和 || 运算符遵循短路规则：当逻辑与（&&）的第一个条件为false时，就不会再去判断第二个条件； 当逻辑或（||）的第一个条件为true时，就不会再去判断第二个条件；

问题3：
当逻辑与（&&）的第一个条件为true时，当逻辑或（||）的第一个条件为false时，该如何判断第二个条件？

GPT答：
对于逻辑与（&&）：
• 当第一个条件为 true 时，仍需判断第二个条件。如果第二个条件为 true，则整个表达式为 true；如果第二个条件为 false，则整个表达式为 false。
• 对于逻辑或（||）：
• 当第一个条件为 false 时，仍需判断第二个条件。如果第二个条件为 true，则整个表达式为 true；如果第二个条件为 false，则整个表达式为 false。

根据gpt的解释，则可以理解问题1“_bool && _bool1 为 false；_bool || _bool1 为 true；”_bool 取值为true，所以逻辑&&仍需判断第二个条件，而_bool1 为 false，所以_bool && _bool1 为 false；但在逻辑 || 中，因为第一个_bool 为true，所以不再判断第二个变量，所以_bool || _bool1 为 true。

2）整型是 Solidity 中的整数，常用包括int（负整数）、uint（正整数）、uint256（256位正整数）

常用的整型运算符包括：
比较运算符（返回布尔值）： <=， <，==， !=， >=， >
算数运算符： +， -， *， /， %（取余），**（幂）

问题4：
int是负整数的表示吗？为什么说是整数，又包括负数；uint是正整数的表示符号吗？
/ 跟%取余有什么不同？
**幂是什么意思，怎么取值？

GPT答：

int 是有符号整数，可以表示正数、负数和零，因此包括负数。它的范围从负的最大值到正的最大值；uint 是无符号整数，仅表示正整数和零，不能表示负数。它的范围从 0 到正的最大值。因此，int 包括负数，而 uint 只表示正整数。

/：表示除法运算，返回商（不包括余数）。表示取余运算，返回除法运算的余数。

幂运算符，用于表示指数运算。它返回一个数的某次幂。例如：2**3 表示 2 的 3 次幂，即 2 × 2 × 2 = 8。

3）地址类型(address)：包括普通地址（address）和payable address；
普通地址（address）: 存储一个 20 字节的值（以太坊地址的大小）。
payable address: 比普通地址多了 transfer 和 send 两个成员方法，用于接收转账。

4）定长字节数组：字节数组分为定长和不定长两种；

定长字节数组: 属于值类型，数组长度在声明之后不能改变。根据字节数组的长度分为 bytes1, bytes8, bytes32 等类型。定长字节数组最多存储 32 bytes 数据，即bytes32。

不定长字节数组: 属于引用类型，数组长度在声明之后可以改变，包括 bytes 等。

基础知识：
0x 是表示十六进制数的前缀;
字节（Byte）：一个字节是由 8 位（bit） 组成的。也就是说，1 字节 = 8 位。
位（Bit）：是计算机中最小的数据单位，可以是 0 或 1。
所以，32个字节 意味着 256位（32字节 × 8 位/字节 = 256 位）。
在十六进制中，每两个数字表示一个字节，0x4D 是一个字节，占 8 位（01001101），它可以存储一个字符，字符 'M' 的 ASCII 编码是 77（十进制），换算为 4D（十六进制）

5）枚举（enum）：是 Solidity 中用户定义的数据类型；它主要用于为 uint 分配名称，使程序易于阅读和维护。

### 

### 2024.09.24

第三节：函数

示例：function <function name>(<parameter types>) {internal|external|public|private} [pure|view|payable] [returns (<return types>)]

1、function：声明函数时的固定用法。要编写函数，就需要以 function 关键字开头。

2、{internal|external|public|private}：函数可见性说明符，共有4种。
1）public：内部和外部均可见。
2）private：只能从本合约内部访问，继承的合约也不能使用。
3）external：只能从合约外部访问（但内部可以通过 this.f() 来调用，f是函数名）。
4）internal: 只能从合约内部访问，继承的合约可以用
注意 1：合约中定义的函数需要明确指定可见性，它们没有默认值。
注意 2：public|private|internal 也可用于修饰状态变量。public变量会自动生成同名的getter函数，用于查询数值。未标明可见性类型的状态变量，默认为internal。

3、[pure|view|payable]：决定函数权限/功能。
1）带着payable的函数，运行的时候可以给合约转入 ETH。
2）pure 函数既不能读取也不能写入链上的状态变量；view函数能读取但也不能写入状态变量。包含 pure 和 view 关键字的函数是不改写链上状态的，因此用户直接调用它们是不需要付 gas（合约的状态变量存储在链上，如果计算不改变链上状态，就可以不用付 gas）。
3）合约中非 pure/view 函数调用 pure/view 函数时需要付gas。
4）修改链上状态的语句
a、写入状态变量。
b、释放事件。
c、创建其他合约。
d、使用 selfdestruct.
e、通过调用发送以太币。
f、调用任何未标记 view 或 pure 的函数。
g、使用低级调用（low-level calls）。
h、使用包含某些操作码的内联汇编。

4、[returns ()]：函数返回的变量类型和名称。

5、internal 函数:只能在合约内部或继承的合约中调用，不能从外部直接访问。

6、external 函数:表示这个函数可以从合约外部调用，也可以在合约内部调用。

问题1:怎么算合约内部？如何算在继承的合约中调用？minus()是什么意思？括号中一般填写什么？合约内部与合约外部有什么区别？minusCall() 函数是一个什么函数？干嘛用的？

GPT答：

合约内部指的是当前合约内定义的函数或状态变量，它们只能被同一合约中的其他函数直接调用。

继承的合约指的是一个合约继承自另一个合约的情况。在 Solidity 中，合约可以通过 is 关键字继承其他合约。

minus() 是一个示例函数名，它代表一个减少（减法）操作的函数。括号中可以填写参数，例如减少的数值。

minusCall() 是一个被定义为 external 的函数，它的主要作用是允许合约外部的调用者间接调用内部的 minus() 函数。

合约内部：指的是函数只能被合约内的其他函数或继承的合约调用，无法被合约外部直接调用。例如，internal 和 private 函数都是只能内部使用的函数。

合约外部：指的是函数可以从合约外部（例如，通过用户或其他合约）调用。external 函数允许其他合约或用户通过交易调用这些函数。

7、payable 是一个特殊的修饰符，它允许函数接收以太币（ETH）；如果一个函数没有标记为 payable，则无法通过该函数向合约发送 ETH。

### 

### 2024.09.25

第四节：函数输出

1、returns和return的区别
returns：跟在函数名后面，用于声明返回的变量类型及变量名。
return：用于函数主体中，返回指定的变量。

2、命名式返回​
若在 returns 中标明返回变量的名称，Solidity 会初始化这些变量，并且自动返回这些函数的值，无需使用 return。也可以在命名式返回中用 return 来返回变量。

示例：

// 命名式返回
function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){
    _number = 2;
    _bool = false;
    _array = [uint256(3),2,1];
}

// 命名式返回，依然支持return
function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){
    return(1, true, [uint256(1),2,5]);
}

3、Solidity 支持使用解构式赋值规则来读取函数的全部或部分返回值。
1）读取所有返回值：声明变量，然后将要赋值的变量用,隔开，按顺序排列。
2）读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。

问题1：什么是解构式赋值

GPT答：

解构式赋值（Destructuring Assignment）是一种编程技术，允许从数组或对象中将多个值同时赋给变量。它的主要特点是可以在一行代码中将复合数据结构（如数组、元组、返回多个值的函数）分解，并分别赋给多个变量。

###

### 2024.09.26

第五节：变量数据存储和作用域

1、Solidity中的引用类型​(Reference Type)：包括数组（array）和结构体（struct）

2、Solidity数据存储位置有三类：storage，memory和calldata。
1）storage：合约里的状态变量默认都是storage，存储在链上（类似计算机的硬盘），数据是持久化的，消耗gas多；
2）memory：函数里的参数和临时变量一般用memory，存储在内存中，不上链（一旦函数执行完毕，数据会被销毁），消耗gas少。尤其是如果返回数据类型是变长的情况下，必须加memory修饰，例如：string, bytes, array和自定义结构。
3）calldata：和memory类似，存储在内存中，不上链，消耗gas少。与memory的不同点在于calldata变量不能修改（immutable），一般用于函数的参数。

3、当变量赋值时，有两种可能的情况：

1）创建副本：即使对新变量进行修改，也不会影响原始变量。
2）创建引用：新变量与原始变量指向同一块存储空间，修改新变量会影响原始变量。

4、赋值行为取决于变量所在的数据位置，规则如下：

1）Storage 赋值给本地的 storage 变量时，赋值的是引用，改变新变量会影响原始变量。
2）Storage 赋值给本地的 memory 变量时，赋值的是副本，修改新变量不会影响原始变量。
3）memory赋值给memory，会创建引用，改变新变量会影响原变量

5、变量按作用域划分有三种：状态变量（state variable），局部变量（local variable）和全局变量(global variable)

1）状态变量：是存储在区块链上的变量。因为这些变量保存在链上，所以对它们的访问和修改都会消耗一定的 gas。状态变量声明在合约内部，且可以在合约的所有函数中被访问和修改。

问题1：状态变量在合约内、函数外声明是什么意思？

GPT答：

合约内：状态变量是合约的一部分，它们在合约体内声明。状态变量存储在区块链上，并且是合约的持久数据。
函数外：状态变量不是在任何函数体内部声明的，而是直接声明在合约的最外层。与函数内部的局部变量不同，状态变量在合约的全局作用域中，这意味着它们可以在合约的任何函数中被访问和修改。

2）局部变量：是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，gas低。
局部变量在函数内声明：局部变量的生命周期仅限于该函数的执行期间，函数执行完毕后，局部变量就会被销毁，不能在合约的其他部分（包括其他函数）中使用。这些变量存在于**内存（memory）**中，并且这些变量不会被存储在区块链上。
3）全局变量是在 Solidity 中预定义的变量，开发者可以在合约的函数中直接使用这些变量，而不需要显式声明。

常用的全局变量：
blockhash(uint blockNumber): (bytes32) 给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。
block.coinbase: (address payable) 当前区块矿工的地址
block.gaslimit: (uint) 当前区块的gaslimit
block.number: (uint) 当前区块的number
block.timestamp: (uint) 当前区块的时间戳，为unix纪元以来的秒
gasleft(): (uint256) 剩余 gas
msg.data: (bytes calldata) 完整call data
msg.sender: (address payable) 消息发送者 (当前 caller)
msg.sig: (bytes4) calldata的前四个字节 (function identifier)
msg.value: (uint) 当前交易发送的 wei 值
block.blobbasefee: (uint) 当前区块的blob基础费用。这是Cancun升级新增的全局变量。
blobhash(uint index): (bytes32) 返回跟当前交易关联的第 index 个blob的版本化哈希（第一个字节为版本号，当前为0x01，后面接KZG承诺的SHA256哈希的最后31个字节）。若当前交易不包含blob，则返回空字节。这是Cancun升级新增的全局变量。


以太单位​
Solidity中不存在小数点，以0代替为小数点，来确保交易的精确度，并且防止精度的损失，利用以太单位可以避免误算的问题，方便程序员在合约中处理货币交易
wei: 1
gwei: 1e9 = 1000000000
ether: 1e18 = 1000000000000000000

时间单位​
seconds: 1
minutes: 60 seconds = 60
hours: 60 minutes = 3600
days: 24 hours = 86400
weeks: 7 days = 604800


第六节：引用类型

1、数组（Array）是Solidity常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）。分为固定长度数组和可变长度数组两种：

1）固定长度数组：在声明时指定数组的长度。用T[k]的格式声明，其中T是元素的类型，k是长度；示例：
// 固定长度 Array
uint[8] array1;
bytes1[5] array2;
address[100] array3;

2）可变长度数组（动态数组）：在声明时不指定数组的长度。用T[ ]的格式声明，其中T是元素的类型，示例：
// 可变长度 Array
uint[ ] array4;
bytes1[ ] array5;
address[ ] array6;
bytes array7;

注意：bytes比较特殊，是数组，但是不用加[ ]。另外，不能用byte[ ]声明单字节数组，可以使用bytes或bytes1[ ]。bytes 比 bytes1[ ]省gas。

2、创建数组的规则
1）对于memory修饰的动态数组，可以用new操作符来创建，但是必须声明长度，并且声明后长度不能改变。

示例：
// memory动态数组
uint[] memory array8 = new uint[](5);
bytes memory array9 = new bytes(9);

2）Solidity 的编译器在处理数组字面常数时，会根据数组中元素的类型来决定整个数组的类型。如果没有明确指定类型，编译器会选择能够适应所有元素的最小类型。对于整数，这个最小类型是 uint8。

3）编译器首先检查数组字面常数的第一个元素的类型。如果第一个元素没有显式指定类型，编译器会继续检查其他元素，并选择能够表示所有元素的最小类型。

4）如果第一个元素的类型明确指定了（例如 uint(1)），编译器会将所有后续元素转换为与第一个元素类型一致的类型。

3、数组成员​
1）length: 数组有一个包含元素数量的length成员，memory数组的长度在创建后是固定的。
2）push(): 动态数组拥有push()成员，可以在数组最后添加一个0元素，并返回该元素的引用。
3）push(x): 动态数组拥有push(x)成员，可以在数组最后添加一个x元素。
4）pop(): 动态数组拥有pop()成员，可以移除数组最后一个元素。

4、结构体：Solidity 支持通过结构体的形式来定义新的类型。结构体中的元素可以是基本类型（如 uint、bool、address 等），也可以是引用类型（如数组、映射等）。结构体允许开发者将多个相关的变量组合在一起，形成一个新的复合数据类型。

5、给结构体赋值的四种方法：
1）使用 storage 引用：这种方式适合在函数内部修改合约状态变量的场景。这样可以减少内存拷贝的开销，并且能直接操作状态变量。
2）直接修改状态变量：当需要简单地修改状态变量的某些字段时，直接使用这种方法非常方便。
3）使用构造函数式的赋值：需要同时赋值多个字段时，使用这种构造函数式的赋值方式可以让代码更简洁、清晰
4）使用 key-value 对的形式赋值：当结构体字段较多，且不需要对所有字段赋值时，使用这种 key-value 方式可以显式地为某些特定字段赋值，而不必依赖字段的顺序。

###

### 2024.09.27

第七节映射类型 mapping（哈希表）


1、在映射中，人们可以通过键（Key）来查询对应的值（Value）

2、映射规则：
1）映射的_KeyType只能选择Solidity内置的值类型，比如uint，address等，不能用自定义的结构体。而_ValueType可以使用自定义的类型。
2）映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量和library函数的参数；
3）为了保持映射数据的持久性和一致性，mapping 只能存储在合约的持久存储区，即 storage 中。
4）如果映射声明为public，那么Solidity会自动给你创建一个getter函数，可以通过Key来查询对应的Value。自动生成的 getter 函数只提供查询功能，而不能修改映射中的数据。

示例：
contract MyContract {
    mapping(address => uint256) public balances;
}

自动生成

function balances(address _addr) public view returns (uint256) {
    return balances[_addr];
}


5）给映射新增的键值对的语法为_Var[_Key] = _Value，其中_Var是映射变量名，_Key和_Value对应新增的键值对。
6）映射中的每个键都是唯一的，不能重复。当给一个键赋值时，如果键已经存在，则新值会覆盖旧值。
7）映射的值是可修改的，并且映射可以动态地增长（不需要提前定义映射的长度）。

3、映射的原理​
1）原理1: 映射不储存任何键（Key）的资讯，也没有length的资讯。
2）原理2: 映射使用keccak256(abi.encodePacked(key, slot))当成offset存取value，其中slot是映射变量定义所在的插槽位置。
3）原理3: 因为Ethereum会定义所有未使用的空间为0，所以未赋值（Value）的键（Key）初始值都是各个type的默认值，如uint的默认值是0。

###

### 2024.09.28

第八节变量初始值

声明但未赋值的变量的初始值（也叫默认值）

1、值类型初始值

1）bool 类型的默认值为 false
2）字符串 (string)的默认值：""（空字符串）
3）所有整型变量（包括有符号整数 int 和无符号整数 uint）的默认值都是 0。
4）enum 类型的默认值是枚举中第一个定义的元素。这是因为 Solidity 默认将枚举类型映射为从 0 开始的整数，第一个枚举项的值为 0。如果一个枚举变量在声明时没有被赋值，它会自动取枚举中第一个元素的值，这个值在内部被表示为 0。

示例：
enum Color { Red, Green, Blue }  // 定义一个枚举类型
Color myColor;                 // 声明一个未赋值的枚举变量，默认值为 Color.Red

5）address 类型的默认值是 0x0000000000000000000000000000000000000000，也就是“零地址”或空地址。
6）对于 internal 、external类型的函数，未初始化时其值为“空白函数”，意味着没有任何实现或指向。

2、引用类型初始值​
1）映射mapping: 所有元素都为其默认值的mapping

对于 mapping 类型，所有键都默认映射到其值类型的默认值。也就是说，如果你通过某个键来查询映射，但从未对该键赋过值，它会返回值类型的默认值。

示例：
mapping(uint => address) 中，如果你查询某个 uint 键但未赋值，它会返回默认地址 0x0000000000000000000000000000000000000000。

2）结构体struct: 所有成员设为其默认值的结构体
结构体是由不同类型的数据组合成的复合数据类型。每个成员变量都有其各自的默认值。
示例：
struct Student {
    uint age;
    string name;
}
Student public student;  // 未初始化的结构体，age 默认为 0，name 默认为 ""

3）数组array
动态数组: [ ]
静态数组（定长）: 所有成员设为其默认值的静态数组

delete操作符：用于将某个变量的值重置为其默认值。

第九节变量（需重点重学）

1、constant（常量）和immutable（不变量）。状态变量声明这两个关键字之后，不能在初始化后更改数值。这样做的好处是提升合约的安全性并节省gas。
2、只有数值变量可以声明constant和immutable；string和bytes可以声明为constant，但不能为immutable。
3、constant变量必须在声明的时候初始化，之后再也不能改变。
4、constant 变量通常用于那些值在合约执行过程中不会改变的场景。
5、immutable 变量和 constant 变量，它们的值在合约部署时就必须被确定，并且之后不能修改；

###

### 2024.09.29

第十节控制流

1、if-else；示例：
function ifElseTest(uint256 _number) public pure returns(bool){
    if(_number == 0){
        return(true);
    }else{
        return(false);
    }
}

2、for循环
function forLoopTest() public pure returns(uint256){
    uint sum = 0;
    for(uint i = 0; i < 10; i++){
        sum += i;
    }
    return(sum);
}

3、while循环
function whileTest() public pure returns(uint256){
    uint sum = 0;
    uint i = 0;
    while(i < 10){
        sum += i;
        i++;
    }
    return(sum);
}

4、do-while循环
function doWhileTest() public pure returns(uint256){
    uint sum = 0;
    uint i = 0;
    do{
        sum += i;
        i++;
    }while(i < 10);
    return(sum);
}

5、三元运算符，常常被用作if语句的简写；规则：? 条件为真的表达式 : 条件为假的表达式；示例：
// 三元运算符 ternary/conditional operator
function ternaryTest(uint256 x, uint256 y) public pure returns(uint256){
    // return the max of x and y
    return x >= y ? x: y; 
}

6、continue（立即进入下一个循环）
7、break（跳出当前循环）

“插入排序”需重点重学

第十一节构造函数和修饰器

1、构造函数（constructor）

1）是一种特殊的函数，每个智能合约只能定义一个构造函数，并且构造函数会在合约部署时自动执行一次；非常适合用于设置合约的初始状态，如定义合约的所有者。

2）0.4.22之前，使用与合约名同名的函数作为构造函数；示例：

pragma solidity =0.4.21;

contract Parents {
    // 与合约名Parents同名的函数就是构造函数
    function Parents() public {
        // 构造函数的逻辑
    }
}

容易存在漏洞：比如将大写P写成了小写p，即将function Parents()写成了function parents()，那么function parents()就不是构造函数了而是普通函数了；

3）0.4.22版本及之后采用了更为严格的构造函数写法，明确使用关键字constructor来定义构造函数。

2、修饰器（modifier）

1）是Solidity特有的语法，用于在函数执行前执行某些检查或附加操作，可以帮助减少代码重复，提高代码的可读性和简洁性。

2）它的主要作用是在函数执行前进行某些预处理，例如地址验证、余额检查等。

###

### 2024.09.30

第十二节事件

1、事件（event）的概念

在Solidity中，事件是EVM（以太坊虚拟机）上的日志抽象，它允许智能合约与外部世界进行通信，通常用于记录重要的链上活动。

2、事件的两个主要特点：

1）响应：
应用程序（如使用ethers.js等库）可以通过RPC接口订阅并监听这些事件，一旦事件被触发，前端可以做出相应的响应操作。这样可以实现链上与链下的互动。
2）经济性：
事件是一种比存储数据更为经济的方式，记录一个事件大约消耗2000 gas。相比之下，链上存储一个新变量至少需要20000 gas。因此，事件通常被用作记录链上活动的方式，而不依赖于状态变量的存储。

3、声明事件

事件的声明由event关键字开始，接着是事件的名称，括号中是事件需要记录的变量类型和变量名；

示例：
event Transfer(address indexed from, address indexed to, uint256 value);

1）event：这是声明事件的关键字
2）ERC20标准中，Transfer事件用于记录代币的转移。
3）address indexed from：记录发送代币的地址，indexed关键字表示这个参数会被索引，便于在日志中快速检索。
4）address indexed to：记录接收代币的地址，indexed同样用于索引。
5）uint256 value：记录转移的代币数量，这个参数没有被indexed，因此不会被索引。

关键字indexed

1）索引功能：事件中的indexed关键字允许最多三个参数被索引，这意味着这些参数将会被储存在日志的topics中。
2）非索引参数：事件中的非索引参数会被存储在日志的data部分，尽管不会被索引，但仍然可以通过读取完整的日志内容来访问这些数据。
3）只有特定的数据类型才能被索引；可以被索引的类型包括：
address
uint、int 等整型
bool
合约类型
枚举类型
4）动态大小的数组、字符串（string）和结构体是不能被索引的，因为这些类型的大小不固定，无法通过topics来有效索引和存储。
5）

4、释放事件

事件释放就是触发一个事件的意思。它通过emit关键字实现，表示在智能合约的执行过程中，记录某些重要的信息，并通知链外的应用程序（例如区块链浏览器、前端应用）发生了某个特定的操作或变化。

emit关键字：在Solidity中，emit用于触发事件。


5、+= 和 -= 是编程中的复合运算符，它们是更简洁的表达方式，用于更新变量的值。
+= 运算符：
表示增加并赋值。
语法：a += b 等同于 a = a + b。
作用：它将 b 的值加到 a 上，然后把结果赋值给 a。

-= 运算符：
表示减少并赋值。
语法：a -= b 等同于 a = a - b。
作用：它将 b 的值从 a 中减去，然后把结果赋值给 a

6、EVM日志 Log​

以太坊虚拟机（EVM）用日志Log来存储Solidity事件，每条日志记录都包含主题topics和数据data两部分。data 部分的变量在存储上消耗的gas相比于 topics 更少。

1）主题 topics​
日志的第一部分是主题数组，用于描述事件，长度不能超过4。它的第一个元素是事件的签名（哈希）。对于上面的Transfer事件，它的事件哈希就是：

2）数据 data​
事件中不带 indexed的参数会被存储在 data 部分中，可以理解为事件的“值”。data 部分的变量不能被直接检索，但可以存储任意大小的数据。

###

### 2024.10.01


第十三节继承
1、继承的主要作用是：复用代码。
1）virtual：父合约中的函数必须用 virtual 标记，子合约才能重写它。
2）override：子合约中如果要重写父合约的函数或状态变量的 getter，必须用 override 标记。
3）注意：用override修饰public变量，会重写与变量同名的getter函数，

2、多重继承​
1）Solidity的合约可以继承多个合约。规则：
2）继承时要按辈分最高到最低的顺序排。比如我们写一个Erzi合约，继承Yeye合约和Baba合约，那么就要写成contract Erzi is Yeye, Baba，而不能写成contract Erzi is Baba, Yeye，不然就会报错。
3）如果某一个函数在多个继承的合约里都存在，比如例子中的hip()和pop()，在子合约里必须重写，不然会报错。
4）重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约名字，例如override(Yeye, Baba)

3、修饰器的继承​
Solidity中的修饰器（Modifier）同样可以继承，用法与函数继承类似，在相应的地方加virtual和override关键字即可。

4、构造函数的继承
子合约可以通过两种方式继承父合约的构造函数。
1）在继承时直接传递参数；
2）在子合约构造函数中调用父合约的构造函数：可以在子合约构造函数内调用父合约的构造函数，并传递经过计算的参数。

5、调用父合约的函数
1）子合约可以通过父合约名.函数名() 的方式直接调用父合约中的函数。这种调用方式是显式地指定了某个父合约中的特定函数。这种方式特别适合在多重继承的情况下，开发者明确想调用某个特定的父合约函数时使用。
2）子合约可以使用 super.函数名() 来调用父合约的函数。super 关键字用于在继承链中调用离子合约最近的父合约函数，特别适合处理多重继承时的函数调用。

6、钻石继承
又称为菱形继承，这种继承结构发生在一个合约同时从多个合约继承时，这些父合约又继承自同一个合约。这种继承关系会形成一个菱形结构，即所谓的钻石继承。
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

/* 继承树：
  God
/      \
Adam Eve
\      /
 people
*/

钻石继承的行为：

1）super 关键字：在多重继承链中，super 关键字会按照继承声明的顺序依次调用链条上的每个合约的函数，而不仅仅是调用最近的父合约。

2）继承顺序：在 people 合约中，foo() 和 bar() 都会先调用 Eve 的 foo() 和 bar()，然后 Eve 又会通过 super 调用 Adam 的实现，最后 Adam 会调用 God 中的实现。这就是钻石继承中 super 的工作方式，它沿着继承链条逐层向上调用父合约的函数。

### 

### 2024.10.02

第十四节抽象合约和接口
1、抽象合约（abstract）

如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体{}中的内容，则必须将该合约标为abstract，不然编译会报错；另外，未实现的函数需要加virtual，以便子合约重写。

2、接口（interface）

a、接口类似于抽象合约，但它不实现任何功能。接口的规则：

1）不能包含状态变量；示例：
interface MyInterface {
    // 错误：接口中不能有状态变量
    // uint public value;
    
    // 正确：只定义函数，没有状态变量
    function getValue() external view returns (uint);
}

2）不能包含构造函数；示例：

interface MyInterface {
    // 错误：接口中不能有构造函数
    // constructor() {}

    function getValue() external view returns (uint);
}

3）不能继承除接口外的其他合约，接口只能继承其他接口，不能继承合约。

4）所有函数都必须是external且不能有函数体；接口中声明的函数必须是 external，表示只能通过外部调用，且不能提供具体的实现（函数体）。这是因为接口只定义行为，不提供实现。
示例：
interface MyInterface {
    // 必须是 external 且不能有函数体
    function getValue() external view returns (uint);
}

问题1：什么是函数体，即具体的实现？

GPT答：
实现（函数体） 就是为一个函数编写具体的逻辑代码，使得该函数可以执行某个操作或返回值。
在接口中，我们只能定义函数的签名（函数的名称、参数类型、返回值类型等），而不能包含具体的实现，即不能写出函数内部的逻辑代码。

5）继承接口的非抽象合约必须实现接口定义的所有功能

b、接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如ERC20或ERC721），其他Dapps和智能合约就知道如何与它交互。

c、接口提供了两个重要的信息：
1）合约里每个函数的bytes4选择器，以及函数签名函数名(每个参数类型）

每个函数都有一个独特的 函数选择器，它是函数签名的哈希值的前四个字节。函数签名包括函数名称和参数类型的组合。

例子：函数 transfer(address, uint256) 的选择器是通过 keccak256("transfer(address,uint256)") 计算出的哈希值的前四个字节，即 bytes4。

2）接口id（更多信息见EIP165）
EIP165 定义了一种标准，用于合约通过接口 ID 来声明自己支持的接口。接口 ID 是通过将接口中所有函数的选择器进行按位或（OR）运算计算出来的。

3）接口与合约ABI（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的ABI，利用abi-to-sol工具，也可以将ABI json文件转换为接口sol文件。

ABI 是合约与外部应用程序（如前端应用或其他智能合约）交互的标准。
如果我们知道一个合约实现了IERC721接口，我们不需要知道它具体代码实现，就可以与它交互。

第十五节异常

三种抛出异常的方法：error，require和assert

一、error
1、节省 Gas：与直接在 revert 中使用字符串相比，error 通过更优化的数据存储方式，能大幅减少 Gas 消耗，特别是在复杂的错误处理场景中。

2、更易调试：自定义 error 的参数可以提供更多的错误信息，帮助开发者更快地定位问题。
3、在实际执行时，如果需要中断操作并抛出异常，error 必须和 revert 命令配合使用。通过 revert 命令，合约可以返回 error 并中止执行。

二、require
1、require 是 Solidity 中用于条件检查的常用命令，当检查的条件不满足时，它会抛出异常并停止合约的执行。

2、语法格式为
require(条件, "异常信息");

条件：是一个布尔表达式，如果条件为 false，则会触发异常。
异常信息：当条件为 false 时，会抛出这个异常消息，方便用户和开发者了解错误原因

3、require 在 Solidity 0.8.0 之前是异常处理的主要方式之一，至今仍然被广泛使用。它的缺点是随着异常信息长度增加，Gas 费用也会增加。

4、error和require比较
1）Gas 消耗：使用 require 抛出带有字符串信息的错误会消耗较多的 Gas，因为字符串存储和处理需要更多资源。而使用 error（Solidity 0.8.4 引入的特性）相比，节省了 Gas 消耗，尤其是在字符串很长的情况下。

2）调试信息：require 中的字符串信息为开发者和用户提供了即时的反馈，但这些信息在链上存储时会占用较多空间。而使用 error 可以通过参数传递更多结构化的信息，节省存储空间并提高效率。

三、assert
1、assert 主要用于检查代码中的不可变条件，通常用来捕捉不应该发生的错误；

2、语法格式为：assert(条件);

条件：是一个布尔表达式。如果条件为 false，合约将抛出异常，并回滚交易。

3、与 require 不同，assert 在抛出异常时不会返回错误信息，因此它通常用于内部错误检查，例如不变式或逻辑保证。

4、assert 和 require 的区别

1）用法场景：
require 通常用于用户输入的验证和条件检查（例如权限验证、函数参数验证等），可以附带错误信息。
assert 则主要用于代码中的逻辑保证，表示某些条件不应该失败。如果失败，意味着合约有逻辑错误。

2）Gas 消耗：
在合约执行失败时，require 会退还剩余的 Gas，但 assert 会消耗掉所有剩余的 Gas。因此，assert 的使用场景更加严格和谨慎。

3）错误信息：
require 可以提供详细的错误信息，帮助调试或向用户提供反馈。
assert 则不会提供任何错误信息，只是单纯地检查条件并在失败时回滚合约。

5.何时使用 assert：assert 一般用于在函数逻辑中检查那些不应该失败的条件。
例如：
• 数学运算中的溢出检查（尽管在 Solidity 0.8 之后，自动处理了溢出检查）。
• 关键状态变量的校验，确保状态在执行过程中保持一致。
• 不变性检查，例如数组长度或映射键值对的存在性。

总结：

1、assert 这种使用方式适合合约内部的不可变条件，而不适合用户输入或外部条件的验证。如果条件不满足，合约将抛出异常并终止执行，但不会提供任何附加的错误信息。

2、因此，assert 通常用于保证合约的核心逻辑的正确性，而不是处理用户错误。如果你需要返回更详细的错误信息或处理用户输入错误，require 会是更好的选择。

3、error方法gas最少，其次是assert，require方法消耗gas最多！

4、Solidity 0.8.0之前的版本，assert抛出的是一个 panic exception，会把剩余的 gas 全部消耗，不会返还。

### 

### 2024.10.03

第十六节函数重载
1、重载函数的定义是：同名函数根据不同的参数类型或数量可以定义多次，但在调用时，必须明确传入的参数类型以匹配正确的函数，否则会报错。此时必须通过明确的类型转换来指定调用哪个函数。


2、Solidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。
示例：
function saySomething() public pure returns(string memory){
    return("Nothing");
}

function saySomething(string memory something) public pure returns(string memory){
    return(something);
}
3、注意：Solidity不允许修饰器（modifier）重载。


第十七节库合约（Library）（重点重学）
库合约是一种特殊的合约，为了提升Solidity代码的复用性和减少gas而存在。库合约是一系列的函数合集；通常用于定义可重用的函数或逻辑。

1、库合约和普通合约主要有以下几点不同：
1）不能存在状态变量：
库合约不能定义状态变量，也不能修改状态。它的设计目的是提供纯逻辑功能，不存储状态或数据。

2）不能继承或被继承：
库合约无法继承其他合约，也不能被其他合约继承。这是为了保持库的独立性和通用性。

3）不能接收以太币：
库合约不具备接收以太币的能力。它的所有函数都是与逻辑相关的，不涉及资金的管理。

4）不可以被销毁：
库合约一旦部署到链上，便无法被销毁。这使得库合约更适合提供持久性的逻辑功能，而不需要担心生命周期管理。

2、库合约中的函数可见性：
1）库合约中的函数如果设置为 public 或 external，则在调用时会触发一次 delegatecall。delegatecall 是一种特殊的调用，它允许库合约的代码在调用合约的上下文中执行。这意味着库合约的函数可以访问并修改调用合约的状态。

2）如果库合约中的函数被设置为 internal，则不会引发 delegatecall，函数的执行上下文直接是在库合约内的。

3、private 函数：
库合约中的 private 函数只能在库合约内部调用，在其他合约中不可见。这使得库合约的私有函数仅能在库内部使用，增强了其封装性。

4、常用的库合约有：
1）Strings：将uint256转换为String
2）Address：判断某个地址是否为合约地址
3）Create2：更安全的使用Create2 EVM opcode
4）Arrays：跟数组相关的库合约

###

### 2024.10.04

第十八节import语句

帮助我们在一个文件中引用另一个文件的内容，提高代码的可重用性和组织性。

1、通过相对路径导入
1）相对路径基于当前合约文件的位置，通常适合在同一项目中管理多个 Solidity 文件时使用。Import.sol 和 被导入文件 在同一文件夹中。
2）./ 代表当前目录，../ 代表上一级目录。如果文件在其他文件夹中，可以用类似 import './folderName/Yeye.sol'; 这种路径形式。
2、通过网络路径导入，网络资源必须可访问并且文件路径完整。
这种方式常用于引用公开的库，比如 OpenZeppelin 提供的标准合约。通常，你可以通过 GitHub 等源代码托管平台上的链接直接引入 Solidity 文件。
3、通过 NPM 目录导入
在使用 NPM 导入时，你需要确保相关依赖已经安装在项目中，并且正确配置了 node_modules 路径。
4、通过全局符号导入合约特定的全局符号
5、所有的 import 语句必须放在代码的开头，即在**pragma 版本声明之后**，而在其他代码之前。

示例：
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// 导入 OpenZeppelin 库中的 Ownable 合约
import '@openzeppelin/contracts/access/Ownable.sol';
// 导入 Yeye.sol 文件中的 Yeye 合约
import { Yeye } from './Yeye.sol';

// 合约定义
contract MyContract is Ownable {
    Yeye public yeye;

    constructor() {
        yeye = new Yeye();
    }
}

第十九节接收ETH receive和fallback
两种特殊的回调函数：receive()和fallback()，主要在两种情况下被使用：
1）接收ETH；
2）处理合约中不存在的函数调用（代理合约proxy contract）

说明：
在Solidity 0.6.x版本之前，语法上只有 fallback() 函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。
0.6版本之后，Solidity才将 fallback() 函数拆分成 receive() 和 fallback() 两个函数。

1、receive()函数：是在合约收到ETH转账时被调用的函数。
1）一个合约最多有一个receive()函数，声明方式与一般函数不一样，不需要function关键字：receive() external payable { ... }。
2）receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable。
3）当合约接收ETH的时候，receive()会被触发。
4）receive()最好不要执行太多的逻辑。

问题1：如何算太多的逻辑、逻辑复杂？

GPT答：

常见的复杂逻辑可能包括以下几种情况：

1）修改存储变量：
存储操作（例如写入合约的状态变量）非常消耗 gas。如果你在 receive() 函数中修改了多个状态变量，可能会耗尽 2300 gas。例如：
receive() external payable {
    // 修改状态变量非常耗费gas
    balanceOf[msg.sender] += msg.value; // 修改存储变量 balanceOf
}

2）调用其他合约：
调用另一个合约的函数，尤其是需要传递参数或等待返回结果的操作，通常需要更多的 gas。例如：
receive() external payable {
    // 调用其他合约的函数消耗大量gas
    otherContract.someFunction(msg.sender, msg.value);
}

3）复杂的循环操作：
如果 receive() 中有循环结构，并且处理的数据量较大，这会导致 gas 迅速耗尽。例如：

receive() external payable {
    for (uint i = 0; i < 1000; i++) {
        // 复杂的循环会耗费大量gas
        doSomething();
    }
}

所以一定注意：
有些恶意合约，会在receive() 函数（老版本的话，就是 fallback() 函数）嵌入恶意消耗gas的内容或者使得执行故意失败的代码，导致一些包含退款和转账逻辑的合约不能正常工作，因此写包含退款等逻辑的合约时候，一定要注意这种情况。

2、回退函数 fallback
1）fallback()函数会在调用合约不存在的函数时被触发。
2）可用于接收ETH，也可以用于代理合约proxy contract。
3）fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收ETH:fallback() external payable { ... }。

3、合约接收ETH时，msg.data为空且存在receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为payable。

### 

### 2024.10.05

第二十节发送ETH

三种方法向其他合约发送ETH，他们是：transfer()，send()和call()，其中call()是被鼓励的用法。

1、call没有gas限制，最为灵活，是最提倡的方法；
1）call()没有gas限制，可以支持对方合约fallback()或receive()函数实现复杂逻辑。
2）call()如果转账失败，不会revert。
3）call()的返回值是(bool, bytes)，其中bool代表着转账成功或失败，需要额外代码处理一下。

2、transfer有2300 gas限制，但是发送失败会自动revert交易，是次优选择；
1）transfer()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。
2）transfer()如果转账失败，会自动revert（回滚交易）
3、send有2300 gas限制，而且发送失败不会自动revert交易，几乎没有人用它。
1）send()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。
2）send()如果转账失败，不会revert。
3）send()的返回值是bool，代表着转账成功或失败，需要额外代码处理一下。



第二十一节调用其他合约

主要方式：

1、通过合约地址直接调用： 使用合约的地址来直接调用目标合约的函数。这种方法最简单，只需知道目标合约的地址和函数签名即可。
// 目标合约 A
contract A {
    uint public value;

    function setValue(uint _value) public {
        value = _value;
    }
}

// 调用合约 B
contract B {
    function callSetValue(address contractA, uint _value) public {
        // 直接使用合约地址和 ABI 编码进行调用
        (bool success, ) = contractA.call(abi.encodeWithSignature("setValue(uint256)", _value));
        require(success, "Call failed");
    }
}

注意事项：

1）使用 call 时，安全性较低，容易导致错误，所以务必进行错误检查（如 require(success)）。
2）call 不会进行返回值类型检查，因此如果目标合约返回值的类型与预期不同，可能会导致数据处理错误。

2、通过合约接口调用： 定义目标合约的接口并使用接口进行调用。这种方法更安全并且便于代码的可读性和可维护性。你可以定义一个目标合约的接口来调用它的函数。

// 目标合约 A
contract A {
    uint public value;

    function setValue(uint _value) public {
        value = _value;
    }

    function getValue() public view returns (uint) {
        return value;
    }
}

// 定义接口 IContractA
interface IContractA {
    function setValue(uint _value) external;
    function getValue() external view returns (uint);
}

// 调用合约 B
contract B {
    function callSetValue(address contractA, uint _value) public {
        // 使用接口进行调用
        IContractA(contractA).setValue(_value);
    }

    function callGetValue(address contractA) public view returns (uint) {
        return IContractA(contractA).getValue();
    }
}

注意事项：
1）接口定义的函数不能包含函数体，只能声明。
2）调用外部合约的函数时，接口更安全、可维护性更高，但前提是需要清楚目标合约的函数签名。

3、继承和合约的内部调用： 通过继承合约，直接调用继承的合约中的函数。如果一个合约继承了另一个合约，那么可以直接在子合约中调用父合约的函数，

// 父合约 A
contract A {
    uint public value;

    function setValue(uint _value) public {
        value = _value;
    }
}

// 子合约 B 继承 A
contract B is A {
    function callSetValue(uint _value) public {
        setValue(_value);  // 直接调用父合约的函数
    }
}

###

### 2024.10.06

第二十二节call

call 是 address 类型的一个低级成员函数，用于与其他合约交互。
call 是推荐的用来发送以太币（ETH）的方式，尤其是当合约没有明确的函数签名时（例如 fallback 或 receive 函数）。
不推荐用 call 调用另一个合约的具体函数，这是因为使用 call 的时候并不会进行返回值类型检查或函数签名检查，这使得代码更容易出现安全漏洞。
call 是一种低级调用，意味着调用者需要承担更大的风险，因为你把主动权交给了目标合约。
当我们不知道目标合约的源代码或 ABI（应用二进制接口）时，不能生成合约的类型变量，这种情况下可以使用 call 函数来进行与目标合约的交互。

低级成员函数”（low-level function）指的是在 Solidity 中那些与智能合约或外部账户交互时不依赖于具体合约的函数接口的函数。这些函数不像接口调用那样有编译期的类型检查和函数签名匹配，因此它们被称为“低级”。

字节码（Bytecode）是在区块链智能合约部署和执行时实际运行的机器可读代码。简单来说，智能合约的源代码（Solidity 写的合约）在编译后会生成字节码，而这个字节码是以太坊虚拟机（EVM）能识别和执行的。


第二十三节delegatecall

1、delegatecall与call的不同与相同：
1）当用户A通过合约B来call合约C的时候，执行的是合约C的函数，上下文(Context，可以理解为包含变量和状态的环境)也是合约C的；
而当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是上下文仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。
即：使用 delegatecall 时，调用目标合约的上下文保持为当前合约，也就是说，目标合约中的状态变量不会被修改，修改的是当前合约的状态变量。

2）上下文不同：
call：目标合约的状态变量和 msg.sender 都是基于目标合约的上下文。
delegatecall：目标合约的代码在调用合约的上下文中执行，因此目标合约的状态变量不会改变，改变的是当前合约的状态变量，msg.sender 也保持不变。
3）不能发送 ETH：delegatecall 只能用于函数调用，不能发送以太币（ETH）。也就是说，使用 delegatecall 时无法像 call 那样指定 value 参数来发送 ETH。
4）可以指定 gas：delegatecall 和 call 一样，可以通过 {gas: gasAmount} 指定调用时使用的 gas 限制。
5）和 call 一样，delegatecall 也使用 abi.encodeWithSignature 来生成二进制数据。此函数将函数的签名（函数名和参数类型）和传递的参数编码为二进制格式。

2、函数签名为"函数名（逗号分隔的参数类型）"。例如abi.encodeWithSignature("f(uint256,address)", _x, _addr)

3、安全隐患
1）在使用 delegatecall 时要非常谨慎，因为它是在当前合约的上下文中执行目标合约的代码；
2）状态变量相同：目标合约的代码将修改当前合约的状态变量，这意味着如果目标合约的代码设计不当，可能会意外修改当前合约的关键数据。
3）确保合约安全：使用 delegatecall 时，必须确保目标合约是安全的，尤其在调用外部不受信任的合约时，否则可能导致合约的状态变量被恶意篡改，造成资金或数据损失。
4、delegatecall 有两个主要的应用场景：
1）代理合约 (Proxy Contract)
代理合约是智能合约升级模式中的一个重要概念。其基本工作原理是将合约的存储部分与逻辑部分分离开来。代理合约负责保存所有相关的变量，而逻辑合约则保存所有函数。每当代理合约需要调用某个函数时，便通过 delegatecall 去执行逻辑合约的代码。
• 存储分离：代理合约保存与合约相关的所有状态变量，而逻辑合约则不保存任何状态数据。
• 升级灵活性：当需要升级智能合约时，只需要将代理合约的地址指向新的逻辑合约，而不需要迁移数据。这种方式极大地增强了合约的升级灵活性。

2）EIP-2535 Diamonds 标准
EIP-2535 钻石标准是一种模块化的智能合约系统，允许在生产或扩展过程中构建可升级的智能合约架构。钻石标准使得多个逻辑合约可以被代理合约调度，从而形成一个系统。每个逻辑合约只负责某一部分功能，代理合约通过 delegatecall 来调用相应的逻辑合约。

###

### 2024.10.07

第二十四节在合约中创建新合约


有两种方法可以在合约中创建新合约，create和create2，create：就是new一个合约，并传入新合约构造函数所需的参数：
Contract x = new Contract{value: _value}(params)

其中Contract是要创建的合约名，x是合约对象（地址），如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。
无论是普通账户（例如钱包地址）还是智能合约账户，都可以利用 CREATE 操作码来创建新的智能合约。

新合约地址的计算公式：
新地址 = hash(创建者地址, nonce)

创建者地址：这是发起合约创建操作的账户地址（可以是普通用户的地址或智能合约的地址）。
nonce：而对于智能合约账户，nonce 则表示它创建的合约总数。每创建一个合约，这个 nonce 值就会加 1。由于 nonce 值是动态变化的，并且与之前的交易或合约创建次数相关，因此使用 CREATE 创建的合约地址在未来是难以预测的。


第二十五节CREATE2 
CREATE2 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。

CREATE2的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用CREATE2创建的合约地址由4个部分决定：
1）0xFF：一个常数，避免和CREATE冲突
2）CreatorAddress: 调用 CREATE2 的当前合约（创建合约）地址。
3）salt（盐）：一个创建者指定的bytes32类型的值，它的主要目的是用来影响新创建的合约的地址。
4）initcode: 新合约的初始字节码（合约的Creation Code和构造函数的参数）。

###

### 2024.10.08

第二十六节删除合约

1、selfdestruct命令可以用来删除智能合约，并将该合约剩余ETH转到指定地址。
2、在 v0.8.18 版本中，selfdestruct 关键字被标记为「不再建议使用」，在一些情况下它会导致预期之外的合约语义，但由于目前还没有代替方案，目前只是对开发者做了编译阶段的警告；
3、EIP-6780减少了SELFDESTRUCT操作码的功能。根据提案描述，当前SELFDESTRUCT仅会被用来将合约中的ETH转移到指定地址，而原先的删除功能只有在合约创建-自毁这两个操作处在同一笔交易时才能生效。所以目前来说：
1）已经部署的合约无法被SELFDESTRUCT了。
2）如果要使用原先的SELFDESTRUCT功能，必须在同一笔交易中创建并SELFDESTRUCT。

4、如何使用selfdestruct
selfdestruct(_addr)；
其中_addr是接收合约中剩余ETH的地址。_addr 地址不需要有receive()或fallback()也能接收ETH。

5、注意事项​
1）对外提供合约销毁接口时，最好设置为只有合约所有者可以调用，可以使用函数修饰符onlyOwner进行函数声明。
2）当合约中有selfdestruct功能时常常会带来安全问题和信任问题，合约中的selfdestruct功能会为攻击者打开攻击向量(例如使用selfdestruct向一个合约频繁转入token进行攻击，这将大大节省了GAS的费用，虽然很少人这么做)，此外，此功能还会降低用户对合约的信心。

###

### 2024.10.09

第二十七节ABI编码解码

1、ABI (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。

2、ABI编码有4个函数：
（1）abi.encode

abi.encode 是 Solidity 中用于将多个参数按照 ABI 规则编码的函数。它能够将不同类型的数据（例如整数、地址、字符串和数组）编码为 32 字节对齐的字节数据。

（2）abi.encodePacked
1）紧凑编码：abi.encodePacked 与 abi.encode 类似，但它会进行紧凑编码，省略其中的填充字节。例如，uint8 类型不会像 uint256 那样占用 32 字节的空间，只占用 1 字节。
2）节省空间：abi.encodePacked 更节省空间，适用于对编码结果有严格字节数要求的场景，例如计算哈希值时。
3）适用场景：当不与其他合约交互，而是需要对数据进行哈希计算或在外部系统之间传递较小数据时，可以使用 abi.encodePacked。

（3）abi.encodeWithSignature
1）abi.encodeWithSignature 常用于与智能合约交互时的外部调用，特别是在合约之间调用函数或通过外部交易调用合约时。你可以将生成的编码数据作为交易的 data 字段发送到合约，合约会根据函数选择器解析并执行对应的函数；
2）多合约交互：当一个合约需要调用另一个合约的函数时，使用 abi.encodeWithSignature 可以生成调用参数并发送。
3）代理合约调用：代理合约可以通过 delegatecall 调用另一个合约的函数，通过 abi.encodeWithSignature 生成函数调用数据。
4）abi.encodeWithSignature：它不仅编码了参数，还包括了函数签名（即函数的哈希值）。这对于智能合约函数调用非常有用，因为以太坊虚拟机（EVM）需要根据函数选择器（哈希的前 4 字节）来确定调用哪个函数。
（4）abi.encodeWithSelector
1）工作过程：
a、函数选择器生成： 通过 bytes4(keccak256(...))，我们生成了函数的 4 字节选择器。
b、参数编码： abi.encodeWithSelector 将函数选择器和后续的参数数据拼接在一起，并对参数进行 ABI 编码。
c、最终编码结果： 函数选择器 + ABI 编码的参数构成了调用合约函数所需的数据。
2）与 abi.encodeWithSignature 的区别：
a、abi.encodeWithSignature：你传入的是函数的完整签名（如 "foo(uint256,address,string,uint256[2])"），系统会自动计算函数选择器。
b、abi.encodeWithSelector：你需要自己手动提供函数选择器，通常是通过对函数签名进行 Keccak-256 哈希计算并截取前 4 个字节得到的。
3）应用场景：
c、代理合约（Proxy Contracts）：代理合约可能需要调用目标合约的函数，但它们只知道函数选择器，而不是完整的函数签名。
d、低级调用：在一些情况下，比如合约之间的低级调用（call 或 delegatecall），直接使用函数选择器来调用函数可能更加高效。
3、ABI解码有1个函数：abi.decode，用于解码abi.encode的数据。
4、ABI的使用场景​
（1）在合约开发中，ABI常配合call来实现对合约的底层调用。
（2）ethers.js中常用ABI实现合约的导入和函数调用。
（3）对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。

###

### 2024.10.10

第二十八节Hash

哈希函数（hash function）是一个密码学概念，它可以将任意长度的消息转换为一个固定长度的值，这个值也称作哈希（hash）。

1、一个好的哈希函数应该具有以下几个特性：

（1）单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。
（2）灵敏性：输入的消息改变一点对它的哈希改变很大。
（3）高效性：从输入的消息到哈希的运算高效。
（4）均一性：每个哈希值被取到的概率应该基本相等。
（5）抗碰撞性：
（6）弱抗碰撞性：给定一个消息x，找到另一个消息x'，使得hash(x) = hash(x')是困难的。
（7）强抗碰撞性：找到任意x和x'，使得hash(x) = hash(x')是困难的。

2、Keccak256函数是Solidity中最常用的哈希函数：哈希 = keccak256(数据);

3、Keccak 是一种哈希算法，它参与了 NIST（美国国家标准技术研究院）组织的 SHA-3 竞赛，并最终被选为新的 SHA-3 标准的基础。

4、Keccak 是一个基于海绵构造的加密哈希函数家族。它最著名的是被选为 SHA-3 竞赛的获胜者，但 Keccak 本身是一个独立的哈希函数，适用于各种加密应用。


第二十九节函数选择器Selector


当我们调用智能合约时，本质上是向目标合约发送了一段calldata，发送的calldata中前4个字节是selector（函数选择器）。

calldata就是告诉智能合约，我要调用哪个函数，以及参数是什么。示例：

0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78

前4个字节0x6a627842就是函数选择器selector；

1、Method ID（方法标识符）：

（1）Method ID 是函数签名经过 Keccak-256 哈希运算后生成的前 4 个字节。方法标识符用于确定智能合约中要调用的具体函数。
（2）例如，如果函数签名为 mint(address)，你可以通过 Keccak-256 哈希算法对这个字符串进行哈希运算，得到的结果前 4 个字节就是 mint 函数的 Method ID。

2、Selector 是指函数的 Method ID，它代表具体的函数调用。

3、函数签名：

（1）函数签名是指函数的名称以及其参数的类型组合在一起的表示形式。
（2）例如，假设有一个函数 mint，它接受一个 address 类型的参数。那么这个函数的签名就是 mint(address)。
（3）函数签名用于在智能合约中区分不同的函数，即使函数的名称相同，只要参数不同，函数签名就会不同。
（4）在函数签名中，所有的类型必须写为具体的位数，例如 uint 必须写成 uint256，而 int 必须写成 int256，否则生成的哈希值会不正确。

4、函数的参数类型主要分为：基础类型参数（如 uint256、address），固定长度类型参数，可变长度类型参数和更复杂的映射类型参数（contract：合约类型、enum：枚举类型、struct：结构体类型）。

5、当函数参数中使用了这些复杂的映射类型参数时，我们在计算该函数的 method id 时，需要将这些复杂类型转换成相应的 ABI 类型，因为 ABI（应用二进制接口）规定了这些复杂类型如何映射到基础类型。

6、映射类型如何转换为 ABI 类型？

（5）contract 类型：在 ABI 中，contract 类型会被转换成 address，因为合约地址是唯一标识一个合约的方式。
（6）struct 类型：结构体会转换为 tuple 类型，具体的结构体成员类型在 tuple 中按顺序排列。例如，struct User 有两个成员 uint256 和 bytes，那么它会被映射为 tuple(uint256,bytes)。
（7）enum 类型：枚举类型会被映射为对应的整数类型，通常是 uint8，因为枚举值通常从 0 开始并按顺序增加。

###

### 2024.10.11

第三十节Try Catch


1、try-catch是现代编程语言几乎都有的处理异常的一种标准方式。

2、在Solidity中，try-catch只能被用于external函数或创建合约时constructor（被视为external函数）的调用。

3、try-catch 只能用于以下两种情况：
（1）external 函数的调用：也就是外部合约的函数调用，external 函数是指只能通过外部调用的合约函数。
（2）合约创建：当你在合约内部创建另一个新合约时，try-catch 也可以用于捕获合约创建过程中的成功或失败情况
（3）如果调用成功，则会执行 try 块中的代码；如果调用失败，则会执行 catch 块中的代码。
（4）catch 块中的代码在函数调用失败时执行，这里可以处理错误，比如记录失败原因或者采取其他操作。失败的情况通常包括合约调用时出现 revert 或 assert，即调用的函数因为条件不满足或者内部错误而失败。

4、在 Solidity 中，this.f() 可以用来代替外部合约调用 externalContract.f()，即你可以在合约内调用当前合约的外部函数。

5、注意：在 try-catch 中，你不能用 this.f() 在构造函数里调用函数，因为在合约的构造函数中，合约还没有完全创建好，不能对自身调用 this.f()。

6、catch 块可以捕获几种不同类型的异常。有三种主要的异常情况：

（1）Error(string memory reason)：捕获通过 revert() 或 require() 抛出的错误。
1）revert()：通过 revert() 触发的异常可以通过 catch Error(string memory reason) 来捕获，通常用于处理函数调用中的错误。
2）require()：require() 触发的异常也会返回一个字符串原因，类似于revert()，同样可以通过 catch Error(string memory reason) 来捕获。

（2）Panic(uint errorCode)：捕获 assert() 失败时产生的错误，以及其他低级别错误，如溢出、除零错误、数组访问越界等。即：assert() 触发的错误是属于 Panic 异常，可以通过 catch Panic(uint errorCode) 来捕获，通常用于捕获断言失败、整数溢出等问题。
（3）catch (bytes memory lowLevelData)：捕获所有其他没有明确定义类型的错误。这通常是由于没有提供明确错误信息的 revert() 调用，或者用户自定义的错误类型。

7、当 revert() 触发异常时，它可以返回一个 bytes 类型的低级别数据。这通常会出现在 catch (bytes memory lowLevelData) 的 catch 块中，用于捕获那些没有附带详细错误信息的 revert() 调用。

8、require() 和 assert() 的异常捕获不会直接返回 bytes 类型的低级数据。require() 通常返回一个 Error 结构，带有一个字符串信息；而 assert() 会返回一个 Panic 异常，带有一个错误代码。

9、try-catch 结构允许捕获外部函数调用或合约创建过程中的异常。当 catch 块捕获到异常时，它不会导致整个合约或方法调用失败，反而是提供了一种机制来处理异常情况，从而避免合约调用失败。

### 2024.10.12

第三十一节ERC20

1、ERC20是以太坊上的代币标准，来自2015年11月V神参与的EIP20。它实现了代币转账的基本逻辑：
（1）账户余额(balanceOf())
（2）转账(transfer())
（3）授权转账(transferFrom())
（4）授权(approve())
（5）代币总供给(totalSupply())
（6）授权转账额度(allowance())
（7）代币信息（可选）：名称(name())，代号(symbol())，小数位数(decimals())

2、IERC20是ERC20代币标准的接口合约，规定了ERC20代币需要实现的函数和事件。
3、函数分为内部和外部两个内容，一个重点是实现，另一个是对外接口，约定共同数据。所以需要ERC20.sol和IERC20.sol两个文件才能实现一个合约。
4、IERC20定义了2个事件：Transfer事件和Approval事件，分别在转账和授权时被释放；
event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed owner, address indexed spender, uint256 value);
5、IERC20定义了6个函数，提供了转移代币的基本功能，并允许代币获得批准，以便其他链上第三方使用：
（1）totalSupply()返回代币总供给
function totalSupply() external view returns (uint256);

（2）balanceOf()返回账户余额
function balanceOf(address account) external view returns (uint256);

（3）transfer()转账
function transfer(address to, uint256 amount) external returns (bool);

（4）allowance()返回授权额度
function allowance(address owner, address spender) external view returns (uint256);

（5）approve()授权
function approve(address spender, uint256 amount) external returns (bool);

（6）transferFrom()授权转账
function transferFrom(
    address from,
    address to,
    uint256 amount
) external returns (bool);


第三十二节代币水龙头

后期自己尝试部署再学习


第三十三节空投合约

1、Airdrop空投合约逻辑非常简单：利用循环，一笔交易将ERC20代币发送给多个地址。

2、合约中包含两个函数
（1）getSum()函数：返回uint数组的和。

Airdrop空投合约逻辑非常简单：利用循环，一笔交易将ERC20代币发送给多个地址。合约中包含两个函数

（2）multiTransferToken()函数：发送ERC20代币空投，包含3个参数：
1）_token：代币合约地址（address类型）
2）_addresses：接收空投的用户地址数组（address[]类型）
3）_amounts：空投数量数组，对应_addresses里每个地址的数量（uint[]类型）

3、multiTransferToken()函数有两个检查：第一个require检查了_addresses和_amounts两个数组长度是否相等；第二个require检查了空投合约的授权额度大于要空投的代币数量总和。


第三十四节ERC721

1、EIP全称 Ethereum Improvement Proposals(以太坊改进建议), 是以太坊开发者社区提出的改进建议, 是一系列以编号排定的文件, 类似互联网上IETF的RFC。

2、ERC全称 Ethereum Request For Comment (以太坊意见征求稿), 用以记录以太坊上应用级的各种开发标准和协议。如典型的Token标准(ERC20, ERC721)、名字注册(ERC26, ERC13), URI范式(ERC67), Library/Package格式(EIP82), 钱包格式(EIP75,EIP85)

3、EIP包含ERC
4、ERC165​
通过ERC165标准，智能合约可以声明它支持的接口，供其他合约检查。简单的说，ERC165就是检查一个智能合约是不是支持了ERC721，ERC1155的接口。

5、IERC721​
IERC721是ERC721标准的接口合约，规定了ERC721要实现的基本函数。它利用tokenId来表示特定的非同质化代币，授权或转账都要明确tokenId；而ERC20只需要明确转账的数额即可。
6、IERC721函数​
（1）balanceOf：返回某地址的NFT持有量balance。
（2）ownerOf：返回某tokenId的主人owner。
（3）transferFrom：普通转账，参数为转出地址from，接收地址to和tokenId。
（4）safeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC721Receiver接口）。参数为转出地址from，接收地址to和tokenId。
（5）approve：授权另一个地址使用你的NFT。参数为被授权地址approve和tokenId。
（6）getApproved：查询tokenId被批准给了哪个地址。
（7）setApprovalForAll：将自己持有的该系列NFT批量授权给某个地址operator。
（8）isApprovedForAll：查询某地址的NFT是否批量授权给了另一个operator地址。
（9）safeTransferFrom：安全转账的重载函数，参数里面包含了data。

7、为了防止误转账，ERC721实现了safeTransferFrom()安全转账函数，目标合约必须实现了IERC721Receiver接口才能接收ERC721代币，不然会revert。IERC721Receiver接口只包含一个onERC721Received()函数。

###

### 2024.10.13

第三十五节荷兰拍卖


1、荷兰拍卖（Dutch Auction）是一种特殊的拍卖形式。 亦称“减价拍卖”，它是指拍卖标的的竞价由高到低依次递减直到第一个竞买人应价（达到或超过底价）时击槌成交的一种拍卖。
2、项目方非常喜欢这种拍卖形式，主要有两个原因

（1）荷兰拍卖的价格由最高慢慢下降，能让项目方获得最大的收入。
（2）拍卖持续较长时间（通常6小时以上），可以避免gas war。

3、DutchAuction状态变量​
合约中一共有9个状态变量，其中有6个和拍卖相关，他们是：
（1）COLLECTOIN_SIZE：NFT总量。
（2）AUCTION_START_PRICE：荷兰拍卖起拍价，也是最高价。
（3）AUCTION_END_PRICE：荷兰拍卖结束价，也是最低价/地板价。
（4）AUCTION_TIME：拍卖持续时长。
（5）AUCTION_DROP_INTERVAL：每过多久时间，价格衰减一次。
（6）auctionStartTime：拍卖起始时间（区块链时间戳，block.timestamp）。


第三十六节默克尔树 Merkle Tree

1、Merkle Tree，也叫默克尔树或哈希树，是区块链的底层加密技术,是一种自下而上构建的加密树，每个叶子是对应数据的哈希，而每个非叶子为它的2个子节点的哈希。

2、MerkleProof库有三个函数：

（1）verify()函数：利用proof数来验证leaf是否属于根为root的Merkle Tree中，如果是，则返回true。它调用了processProof()函数。
（2）processProof()函数：利用proof和leaf依次计算出Merkle Tree的root。它调用了_hashPair()函数。
（3）_hashPair()函数：用keccak256()函数计算非根节点对应的两个子节点的哈希（排序后）。

3、合约中共有4个函数：
（1）构造函数：初始化NFT的名称和代号，还有Merkle Tree的root。
（2）mint()函数：利用白名单铸造NFT。参数为白名单地址account，铸造的tokenId，和proof。首先验证address是否在白名单中，验证通过则把序号为tokenId的NFT铸造给该地址，并将它记录到mintedAddress。此过程中调用了_leaf()和_verify()函数。
（3）_leaf()函数：计算了Merkle Tree的叶子地址的哈希。
（4）_verify()函数：调用了MerkleProof库的verify()函数，进行Merkle Tree验证


第三十七节数字签名 Signature

1、数字签名ECDSA
双椭圆曲线数字签名算法（ECDSA），基于双椭圆曲线“私钥-公钥”对的数字签名算法。

2、ECDSA主要起到了三个作用：
（1）身份认证：证明签名方是私钥的持有人。
（2）不可否认：发送方不能否认发送过这个消息。
（3）完整性：通过验证针对传输消息生成的数字签名，可以验证消息是否在传输过程中被篡改。

3、ECDSA标准中包含两个部分：
（1）签名者利用私钥（隐私的）对消息（公开的）创建签名（公开的）。
（2）其他人使用消息（公开的）和签名（公开的）恢复签名者的公钥（公开的）并验证签名。

4、创建签名​
（1）打包消息： 在以太坊的ECDSA标准中，被签名的消息是一组数据的keccak256哈希，为bytes32类型。我们可以把任何想要签名的内容利用abi.encodePacked()函数打包，然后用keccak256()计算哈希，作为消息。
（2）计算以太坊签名消息： 消息可以是能被执行的交易，也可以是其他任何形式。为了避免用户误签了恶意交易，EIP191提倡在消息前加上"\x19Ethereum Signed Message:\n32"字符，并再做一次keccak256哈希，作为以太坊签名消息。
（3）利用web3.py签名： 批量调用中更倾向于使用代码进行签名;
（4）通过签名和消息恢复公钥：签名是由数学算法生成的。这里我们使用的是rsv签名，签名中包含r, s, v三个值的信息。而后，我们可以通过r, s, v及以太坊签名消息来求得公钥。

5、注意事项
（1）签名是链下的，不需要gas，因此这种白名单发放模式比Merkle Tree模式还要经济
（2）由于用户要请求中心化接口去获取签名，不可避免的牺牲了一部分去中心化；
（3）额外还有一个好处是白名单可以动态变化，而不是提前写死在合约里面了，因为项目方的中心化后端接口可以接受任何新地址的请求并给予白名单签名。

6、SignatureNFT合约
（1）合约中共有两个状态变量：
1）signer：公钥，项目方签名地址。
2）mintedAddress是一个mapping，记录了已经mint过的地址。

（2）合约中共有4个函数：
1）构造函数初始化NFT的名称和代号，还有ECDSA的签名地址signer。
2）mint()函数接受地址address，tokenId和_signature三个参数，验证签名是否有效：如果有效，则把tokenId的NFT铸造给address地址，并将它记录到mintedAddress。它调用了getMessageHash()，ECDSA.toEthSignedMessageHash()和verify()函数。
3）getMessageHash()函数将mint地址（address类型）和tokenId（uint256类型）拼成消息。
4）verify()函数调用了ECDSA库的verify()函数，来进行ECDSA签名验证。



第三十八节NFT交易所

后期自己尝试部署再学习


第三十九节链上随机数

后期再学习

###

### 2024.10.14

第四十节EIP1155

以太坊EIP1155提出了一个多代币标准ERC1155，允许一个合约包含多个同质化和非同质化代币。

ERC1155主要应用于GameFi中。

IERC1155 是 ERC1155 标准的接口：IERC1155 提供了一套标准的接口，开发者可以按照这个接口实现具体的 ERC1155 功能。

ERC20还是ERC721标准，每个合约都对应一个独立的代币。

区别：
ERC721中，每个代币都有一个tokenId作为唯一标识，每个tokenId只对应一个代币；
而在ERC1155中，每一种代币都有一个id作为唯一标识，每个id对应一种代币。

区分ERC1155中的某类代币是同质化还是非同质化代币:
如果某个id对应的代币总量为1，那么它就是非同质化代币，类似ERC721；如果某个id对应的代币总量大于1，那么他就是同质化代币

IERC1155接口合约抽象了EIP1155需要实现的功能，其中包含4个事件和6个函数。与ERC721不同，因为ERC1155包含多类代币，它实现了批量转账和批量余额查询，一次操作多种代币。

问题：什么叫IERC1155接口合约抽象了EIP1155需要实现的功能？

GPT答：

当说 IERC1155 抽象了 EIP1155 的功能 时，意思是 IERC1155 只定义了接口（函数的名字、参数和返回值），而没有提供具体的实现。开发者在编写智能合约时，需要根据 IERC1155 的接口来实现这些功能，确保合约符合 ERC1155 标准。

IERC1155事件​
（1）TransferSingle事件：单类代币转账事件，在单币种转账时释放。
（2）TransferBatch事件：批量代币转账事件，在多币种转账时释放。
（3）ApprovalForAll事件：批量授权事件，在批量授权时释放。
（4）URI事件：元数据地址变更事件，在uri变化时释放。
IERC1155函数​
（1）balanceOf()：单币种余额查询，返回account拥有的id种类的代币的持仓量。
（2）balanceOfBatch()：多币种余额查询，查询的地址accounts数组和代币种类ids数组的长度要相等。
（3）setApprovalForAll()：批量授权，将调用者的代币授权给operator地址。。
（4）isApprovedForAll()：查询批量授权信息，如果授权地址operator被account授权，则返回true。
（5）safeTransferFrom()：安全单币转账，将amount单位id种类的代币从from地址转账给to地址。如果to地址是合约，则会验证是否实现了onERC1155Received()接收函数。
（6）safeBatchTransferFrom()：安全多币转账，与单币转账类似，只不过转账数量amounts和代币种类ids变为数组，且长度相等。如果to地址是合约，则会验证是否实现了onERC1155BatchReceived()接收函数。



为了避免代币被转入黑洞合约，ERC1155要求代币接收合约继承IERC1155Receiver并实现两个接收函数：
（1）onERC1155Received()：单币转账接收函数，接受ERC1155安全转账safeTransferFrom 需要实现并返回自己的选择器0xf23a6e61。
（2）onERC1155BatchReceived()：多币转账接收函数，接受ERC1155安全多币转账safeBatchTransferFrom 需要实现并返回自己的选择器0xbc197c81。

ERC1155主合约包含4个状态变量：
（1）name：代币名称
（2）symbol：代币代号
（3）_balances：代币持仓映射，记录代币种类id下某地址account的持仓量balances。
（4）_operatorApprovals：批量授权映射，记录持有地址给另一个地址的授权情况。

ERC1155函数​
ERC1155主合约包含16个函数：
（1）构造函数：初始化状态变量name和symbol。
（2）supportsInterface()：实现ERC165标准，声明它支持的接口，供其他合约检查。
（3）balanceOf()：实现IERC1155的balanceOf()，查询持仓量。与ERC721标准不同，这里需要输入查询的持仓地址account以及币种id。
（4）balanceOfBatch()：实现IERC1155的balanceOfBatch()，批量查询持仓量。
（5）setApprovalForAll()：实现IERC1155的setApprovalForAll()，批量授权，释放ApprovalForAll事件。
（6）isApprovedForAll()：实现IERC1155的isApprovedForAll()，查询批量授权信息。
（7）safeTransferFrom()：实现IERC1155的safeTransferFrom()，单币种安全转账，释放TransferSingle事件。与ERC721不同，这里不仅需要填发出方from，接收方to，代币种类id，还需要填转账数额amount。
（8）safeBatchTransferFrom()：实现IERC1155的safeBatchTransferFrom()，多币种安全转账，释放TransferBatch事件。
（9）_mint()：单币种铸造函数。
（10）_mintBatch()：多币种铸造函数。
（11）_burn()：单币种销毁函数。
（12）_burnBatch()：多币种销毁函数。
（13）_doSafeTransferAcceptanceCheck：单币种转账的安全检查，被safeTransferFrom()调用，确保接收方为合约的情况下，实现了onERC1155Received()函数。
（14）_doSafeBatchTransferAcceptanceCheck：多币种转账的安全检查，，被safeBatchTransferFrom调用，确保接收方为合约的情况下，实现了onERC1155BatchReceived()函数。
（15）uri()：返回ERC1155的第id种代币存储元数据的网址，类似ERC721的tokenURI。
（16）baseURI()：返回baseURI，uri就是把baseURI和id拼接在一起，需要开发重写。


第四十一节WETH

1、WETH (Wrapped ETH)是ETH的带包装版本

2、WETH的开发是为了提高区块链之间的互操作性 ，并使ETH可用于去中心化应用程序（dApps）

3、WETH符合ERC20标准，它比普通的ERC20多了两个功能：

（1）存款：包装，用户将ETH存入WETH合约，并获得等量的WETH。
（2）取款：拆包装，用户销毁WETH，并获得等量的ETH

4、WETH合约共有2个事件：
（1）Deposit：存款事件，在存款的时候释放。
（2）Withdraw：取款事件，在取款的时候释放。

5、除了ERC20标准的函数外，WETH合约有5个函数：
（1）构造函数：初始化WETH的名字和代号。
（2）回调函数：fallback()和receive()，当用户往WETH合约转ETH的时候，会自动触发deposit()存款函数，获得等量的WETH。
（3）deposit()：存款函数，当用户存入ETH时，给他铸造等量的WETH。
（4）withdraw()：取款函数，让用户销毁WETH，并归还等量的ETH


第四十二节分账

1、分账合约(PaymentSplit)具有以下几个特点：
（1）在创建合约时定好分账受益人payees和每人的份额shares。
（2）份额可以是相等，也可以是其他任意比例。
（3）在该合约收到的所有ETH中，每个受益人将能够提取与其分配的份额成比例的金额。
（4）分账合约遵循Pull Payment模式，付款不会自动转入账户，而是保存在此合约中。受益人通过调用release()函数触发实际转账。

2、分账合约中共有3个事件：
（1）PayeeAdded：增加受益人事件。
（2）PaymentReleased：受益人提款事件。
（3）PaymentReceived：分账合约收款事件。

3、分账合约中共有5个状态变量，用来记录受益地址、份额、支付出去的ETH等变量：
（1）totalShares：总份额，为shares的和。
（2）totalReleased：从分账合约向受益人支付出去的ETH，为released的和。
（3）payees：address数组，记录受益人地址
（4）shares：address到uint256的映射，记录每个受益人的份额。
（5）released：address到uint256的映射，记录分账合约支付给每个受益人的金额。

4、分账合约中共有6个函数：
（1）构造函数：始化受益人数组_payees和分账份额数组_shares，其中数组长度不能为0，两个数组长度要相等。_shares中元素要大于0，_payees中地址不能为0地址且不能有重复地址。
（2）receive()：回调函数，在分账合约收到ETH时释放PaymentReceived事件。
（3）release()：分账函数，为有效受益人地址_account分配相应的ETH。任何人都可以触发这个函数，但ETH会转给受益人地址account。调用了releasable()函数。
（4）releasable()：计算一个受益人地址应领取的ETH。调用了pendingPayment()函数。
（5）pendingPayment()：根据受益人地址_account, 分账合约总收入_totalReceived和该地址已领取的钱_alreadyReleased，计算该受益人现在应分的ETH。
（6）_addPayee()：新增受益人函数及其份额函数。在合约初始化的时候被调用，之后不能修改。

###

### 2024.10.15

第四十三节线性释放

1、代币归属条款（token vesting），在归属期内逐步释放代币，减缓抛压，并防止团队和资本方过早躺平。

2、线性释放指的是代币在归属期内匀速释放。

3、合约TokenVesting锁仓并线性释放ERC20代币的逻辑：
（1）项目方规定线性释放的起始时间、归属期和受益人。
（2）项目方将锁仓的ERC20代币转账给TokenVesting合约。
（3）受益人可以调用release函数，从合约中取出释放的代币。

4、线性释放合约中共有1个事件。
ERC20Released：提币事件，当受益人提取释放代币时释放。

5、线性释放合约中共有4个状态变量。
（1）beneficiary：受益人地址。
（2）start：归属期起始时间戳。
（3）duration：归属期，单位为秒。
（4）erc20Released：代币地址->释放数量的映射，记录受益人已领取的代币数量。

6、线性释放合约中共有3个函数。
（1）构造函数：初始化受益人地址，归属期(秒), 起始时间戳。参数为受益人地址beneficiaryAddress和归属期durationSeconds。为了方便，起始时间戳用的部署时的区块链时间戳block.timestamp。
（2）release()：提取代币函数，将已释放的代币转账给受益人。调用了vestedAmount()函数计算可提取的代币数量，释放ERC20Released事件，然后将代币transfer给受益人。参数为代币地址token。
（3）vestedAmount()：根据线性释放公式，查询已经释放的代币数量。开发者可以通过修改这个函数，自定义释放方式。参数为代币地址token和查询的时间戳timestamp。


第四十四节代币锁

1、代币锁(Token Locker)是一种简单的时间锁合约，它可以把合约中的代币锁仓一段时间，受益人在锁仓期满后可以取走代币。代币锁一般是用来锁仓流动性提供者LP代币的。


2、锁仓ERC20代币的合约TokenLocker的逻辑：
（1）开发者在部署合约时规定锁仓的时间，受益人地址，以及代币合约。
（2）开发者将代币转入TokenLocker合约。
（3）在锁仓期满，受益人可以取走合约里的代币。


3、TokenLocker合约中共有2个事件。
（1）TokenLockStart：锁仓开始事件，在合约部署时释放，记录受益人地址，代币地址，锁仓起始时间，和结束时间。
（2）Release：代币释放事件，在受益人取出代币时释放，记录记录受益人地址，代币地址，释放代币时间，和代币数量。


4、TokenLocker合约中共有4个状态变量。
（1）token：锁仓代币地址。
（2）beneficiary：受益人地址。
（3）locktime：锁仓时间(秒)。
（4）startTime：锁仓起始时间戳(秒)。


5、TokenLocker合约中共有2个函数。
（1）构造函数：初始化代币合约，受益人地址，以及锁仓时间。
（2）release()：在锁仓期满后，将代币释放给受益人。需要受益人主动调用release()函数提取代币。


第四十五节时间锁


1、时间锁在区块链是一段代码，他可以将智能合约的某些功能锁定一段时间。可以大大改善智能合约的安全性。

2、时间锁Timelock合约的逻辑：

（1）在创建Timelock合约时，项目方可以设定锁定期，并把合约的管理员设为自己。
（2）时间锁主要有三个功能：

1）创建交易，并加入到时间锁队列。
2）在交易的锁定期满后，执行交易。
3）后悔了，取消时间锁队列中的某些交易。

（3）项目方一般会把时间锁合约设为重要合约的管理员，例如金库合约，再通过时间锁操作他们。
（4）时间锁合约的管理员一般为项目的多签钱包，保证去中心化。

3、Timelock合约中共有4个事件。
（1）QueueTransaction：交易创建并进入时间锁队列的事件。
（2）ExecuteTransaction：锁定期满后交易执行的事件。
（3）CancelTransaction：交易取消事件。
（4）NewAdmin：修改管理员地址的事件。

4、Timelock合约中共有4个状态变量。
（1）admin：管理员地址。
（2）delay：锁定期。
（3）GRACE_PERIOD：交易过期时间。如果交易到了执行的时间点，但在GRACE_PERIOD没有被执行，就会过期。
（4）queuedTransactions：进入时间锁队列交易的标识符txHash到bool的映射，记录所有在时间锁队列中的交易

5、Timelock合约中共有2个modifier修饰器。
（1）onlyOwner()：被修饰的函数只能被管理员执行。
（2）onlyTimelock()：被修饰的函数只能被时间锁合约执行。

6、Timelock合约中共有7个函数。
（1）构造函数：初始化交易锁定时间（秒）和管理员地址。
（2）queueTransaction()：创建交易并添加到时间锁队列中。参数比较复杂，因为要描述一个完整的交易：
1）target：目标合约地址
2）value：发送ETH数额
3）signature：调用的函数签名（function signature）
4）data：交易的call data
5）executeTime：交易执行的区块链时间戳。
（3）调用这个函数时，要保证交易预计执行时间executeTime大于当前区块链时间戳+锁定时间delay。交易的唯一标识符为所有参数的哈希值，利用getTxHash()函数计算。进入队列的交易会更新在queuedTransactions变量中，并释放QueueTransaction事件。
（4）executeTransaction()：执行交易。它的参数与queueTransaction()相同。要求被执行的交易在时间锁队列中，达到交易的执行时间，且没有过期。执行交易时用到了solidity的低级成员函数call，在第22讲中有介绍。
（5）cancelTransaction()：取消交易。它的参数与queueTransaction()相同。它要求被取消的交易在队列中，会更新queuedTransactions并释放CancelTransaction事件。
（6）changeAdmin()：修改管理员地址，只能被Timelock合约调用。
（7）getBlockTimestamp()：获取当前区块链时间戳。
（8）getTxHash()：返回交易的标识符，为很多交易参数的hash。


第四十六节代理合约

1、代理模式将合约数据和逻辑分开，分别保存在不同合约中。

2、数据（状态变量）存储在代理合约中，而逻辑（函数）保存在另一个逻辑合约中。代理合约（Proxy）通过delegatecall，将函数调用全权委托给逻辑合约（Implementation）执行，再把最终的结果返回给调用者（Caller）。

3、代理模式主要有两个好处：
（1）可升级：当我们需要升级合约的逻辑时，只需要将代理合约指向新的逻辑合约。
（2）省gas：如果多个合约复用一套逻辑，我们只需部署一个逻辑合约，然后再部署多个只保存数据的代理合约，指向逻辑合约。

4、代理合约的三个部分：代理合约Proxy，逻辑合约Logic，和一个调用示例Caller。

5、代理合约的逻辑：
（1）首先部署逻辑合约Logic。
（2）创建代理合约Proxy，状态变量implementation记录Logic合约地址。
（3）Proxy合约利用回调函数fallback，将所有调用委托给Logic合约
（4）最后部署调用示例Caller合约，调用Proxy合约

6、Logic合约和Proxy合约的状态变量存储结构相同，不然delegatecall会产生意想不到的行为，有安全隐患。

7、内联汇编操作码：
（1）calldatacopy(t, f, s)：将calldata（输入数据）从位置f开始复制s字节到mem（内存）的位置t。
（2）delegatecall(g, a, in, insize, out, outsize)：调用地址a的合约，输入为mem[in..(in+insize)) ，输出为mem[out..(out+outsize))， 提供gwei的以太坊gas。这个操作码在错误时返回0，在成功时返回1。
（3）returndatacopy(t, f, s)：将returndata（输出数据）从位置f开始复制s字节到mem（内存）的位置t。
（4）switch：基础版if/else，不同的情况case返回不同值。可以有一个默认的default情况。
（5）return(p, s)：终止函数执行, 返回数据mem[p..(p+s))。
（6）revert(p, s)：终止函数执行, 回滚状态，返回数据mem[p..(p+s))。

8、逻辑合约Logic；包含2个变量，1个事件，1个函数：
（1）implementation：占位变量，与Proxy合约保持一致，防止插槽冲突。
（2）x：uint变量，被设置为99。
（3）CallSuccess事件：在调用成功时释放。
（4）increment()函数：会被Proxy合约调用，释放CallSuccess事件，并返回一个uint，它的selector为0xd09de08a

9、调用者合约Caller；有1个变量，2个函数：
（1）proxy：状态变量，记录代理合约地址。
（2）构造函数：在部署合约时初始化proxy变量。
（3）increase()：利用call来调用代理合约的increment()函数，并返回一个uint。

###

### 2024.10.16


第四十七节可升级合约

1、可升级合约就是一个可以更改逻辑合约的代理合约。
2、一个简单的可升级合约包含3个合约：代理合约，旧的逻辑合约，和新的逻辑合约。
3、代理合约包含
（1）3个变量：
1）implementation：逻辑合约地址。
2）admin：admin地址。
3）words：字符串，可以通过逻辑合约的函数改变。

（2）3个函数
1）构造函数：初始化admin和逻辑合约地址。
2）fallback()：回调函数，将调用委托给逻辑合约。
3）upgrade()：升级函数，改变逻辑合约地址，只能由admin调用
4、旧逻辑合约​
这个逻辑合约包含3个状态变量，与保持代理合约一致，防止插槽冲突。它只有一个函数foo()，将代理合约中的words的值改为"old"。
5、新逻辑合约​
这个逻辑合约包含3个状态变量，与保持代理合约一致，防止插槽冲突。它只有一个函数foo()，将代理合约中的words的值改为"new"。


第四十八节透明代理Transparent Proxy

1、存在的问题：管理员可能会因为“函数选择器冲突”，在调用逻辑合约的函数时，误调用代理合约的可升级函数。

两种解决方案：
（1）透明代理：限制管理员的权限，不让他调用任何逻辑合约的函数；
（2）通用可升级代理

2、透明代理的逻辑：
（1）管理员变为工具人，仅能调用代理合约的可升级函数对合约升级，不能通过回调函数调用逻辑合约。
（2）其它用户不能调用可升级函数，但是可以调用逻辑合约的函数。

3、代理合约的fallback()函数限制了管理员地址的调用。代理合约包含：
（1）3个变量：
1）implementation：逻辑合约地址。
2）admin：admin地址。
3）words：字符串，可以通过逻辑合约的函数改变。
（2）3个函数
1）构造函数：初始化admin和逻辑合约地址。
2）fallback()：回调函数，将调用委托给逻辑合约，不能由admin调用。
3）upgrade()：升级函数，改变逻辑合约地址，只能由admin调用。

4、逻辑合约：包含3个状态变量，与保持代理合约一致，防止插槽冲突；包含一个函数foo()，旧逻辑合约会将words的值改为"old"，新的会改为"new"。


第四十九节通用可升级代理

1、UUPS（universal upgradeable proxy standard，通用可升级代理）将升级函数放在逻辑合约中。这样一来，如果有其它函数与升级函数存在“选择器冲突”，编译时就会报错。

2、普通可升级合约，透明代理，和UUPS的不同点：
标准	可升级函数在	是否回“选择器冲突”	缺点
可升级代理	Proxy合约	会	选择器冲突
透明代理	Proxy合约	不会	费gas
UUPS	Logic合约	不会	更复杂


3、UUPS的代理合约的升级函数被放在了逻辑合约中。包含：
（1）3个变量：
1）implementation：逻辑合约地址。
2）admin：admin地址。
3）words：字符串，可以通过逻辑合约的函数改变。
（2）2个函数
1）构造函数：初始化admin和逻辑合约地址。
2）fallback()：回调函数，将调用委托给逻辑合约。


4、UUPS的逻辑合约与第47讲中的不同是多了个升级函数。UUPS逻辑合约包含3个状态变量，与保持代理合约一致，防止插槽冲突。它包含2个函数：
（1）upgrade()：升级函数，将改变逻辑合约地址implementation，只能由admin调用。
（2）foo()：旧UUPS逻辑合约会将words的值改为"old"，新的会改为"new"。

5、与透明代理不同，UUPS将升级函数放在了逻辑合约中，从而使得"选择器冲突"不能通过编译。相比透明代理，UUPS更省gas，但也更复杂。


第五十节多签钱包

1、多签钱包是一种电子钱包，特点是交易被多个私钥持有者（多签人）授权后才能执行；
2、在以太坊上的多签钱包其实是智能合约，属于合约钱包。
3、多签钱包MultisigWallet合约的逻辑：
（1）设置多签人和门槛（链上）：部署多签合约时，我们需要初始化多签人列表和执行门槛（至少n个多签人签名授权后，交易才能执行）。
（2）创建交易（链下）：一笔待授权的交易包含以下内容：
1）to：目标合约。
2）value：交易发送的以太坊数量。
3）data：calldata，包含调用函数的选择器和参数。
4）nonce：初始为0，随着多签合约每笔成功执行的交易递增的值，可以防止签名重放攻击。
5）chainid：链id，防止不同链的签名重放攻击。
（3）收集多签签名（链下）：将上一步的交易ABI编码并计算哈希，得到交易哈希，然后让多签人签名，并拼接到一起的到打包签名。
（4）调用多签合约的执行函数，验证签名并执行交易（链上）。

4、MultisigWallet合约有2个事件，ExecutionSuccess和ExecutionFailure，分别在交易成功和失败时释放，参数为交易哈希。

5、MultisigWallet合约有5个状态变量：
（1）owners：多签持有人数组
（2）isOwner：address => bool的映射，记录一个地址是否为多签持有人。
（3）ownerCount：多签持有人数量
（4）threshold：多签执行门槛，交易至少有n个多签人签名才能被执行。
（5）nonce：初始为0，随着多签合约每笔成功执行的交易递增的值，可以防止签名重放攻击。

6、MultisigWallet合约有6个函数：

（1）构造函数：调用_setupOwners()，初始化和多签持有人和执行门槛相关的变量。
（2）_setupOwners()：在合约部署时被构造函数调用，初始化owners，isOwner，ownerCount，threshold状态变量。传入的参数中，执行门槛需大于等于1且小于等于多签人数；多签地址不能为0地址且不能重复。
（3）execTransaction()：在收集足够的多签签名后，验证签名并执行交易。传入的参数为目标地址to，发送的以太坊数额value，数据data，以及打包签名signatures。打包签名就是将收集的多签人对交易哈希的签名，按多签持有人地址从小到大顺序，打包到一个[bytes]数据中。这一步调用了encodeTransactionData()编码交易，调用了checkSignatures()检验签名是否有效、数量是否达到执行门槛。
（4）checkSignatures()：检查签名和交易数据的哈希是否对应，数量是否达到门槛，若否，交易会revert。单个签名长度为65字节，因此打包签名的长度要长于threshold * 65。调用了signatureSplit()分离出单个签名。这个函数的大致思路：
1）用ecdsa获取签名地址.
2）利用 currentOwner > lastOwner 确定签名来自不同多签（多签地址递增）。
3）利用isOwner[currentOwner]确定签名者为多签持有人。
（5）signatureSplit()：将单个签名从打包的签名分离出来，参数分别为打包签名signatures和要读取的签名位置pos。利用了内联汇编，将签名的r，s，和v三个值分离出来。
（6）encodeTransactionData()：将交易数据打包并计算哈希，利用了abi.encode()和keccak256()函数。这个函数可以计算出一个交易的哈希，然后在链下让多签人签名并收集，再调用execTransaction()函数执行。

###

<!-- Content_END -->
